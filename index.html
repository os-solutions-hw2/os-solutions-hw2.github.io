
<html>
<head>
  <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Homework: bootstrap and x86 assembly</title>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
</head>
<body style="margin: 20;">

<hr>

<h1>Homework: 2</h1>

(total 14 marks)

<p>
<b>1.1 The ROM BIOS </b>(1 marks)
<pre>
[f000:fff0]    0xffff0: ljmp   $0xf000,$0xe05b
[f000:e05b]    0xfe05b: cmpl   $0x0,%cs:0x6c48
[f000:e062]    0xfe062: jne    0xfd2e1
[f000:e066]    0xfe066: xor    %dx,%dx
[f000:e068]    0xfe068: mov    %dx,%ss
[f000:e06a]    0xfe06a: mov    $0x7000,%esp
[f000:e070]    0xfe070: mov    $0xf3691,%edx
[f000:e076]    0xfe076: jmp    0xfd165
</pre>
</p>
  
<p>
<b>1.2 The Boot Loader </b>(2 mark)
<pre>
Before ljmp in bootasm.S: cs=0x0, eip = 0x7c2c (1 mark)
After ljmp in bootasm.S: cs=0x8, eip = 0x7c31 (1 mark)
</pre>
</p>

<p>
<b>1.3 Pointers in C</b> (2 marks)
<pre>
Before:
c8 00 00 00 90 01 00 00 2d 01 00 00 2e 01 00 00 (1 mark)
After:
c8 00 00 00 90 f4 01 00 00 01 00 00 2e 01 00 000 (1 mark)
</pre>
</p>

<p>
<b>1.4 Loading the Kernel</b> (2 marks)<br>
They are different because the kernel has been loaded at 0x100000 by
the loader. (1 marks)<br>
At 0x100000 lives the "text" (or code) section of the kernel. (1 mark)
<br>
  </p>

<p>
<b>Variable naming. </b>(3 marks) <br>
</p>


<p>
<b>Caller and callee save registers</b> (3 marks).<br>
Basically the compiler should try and use callee-saved registers
first in the caller; and vice-versa. Roughly half-half split ensures
fairness across caller and callee.
</p>

<p>
<b>Fastest implementation while respecting calling conventions </b>(2 marks)<br>
<code>jmp _g</code><br>
<code>call _g; ret</code> (1.5 marks)
</p>

<p><b>Assignment: fork, caching, and file-descriptor inheritance</b>
<pre>
n=0   0
  1   2
  2   6
  3   14

T(n) = 2*(1 + T(n-1))
</pre>
</p>

<p>
When you use printf(), the output does not immediately go to the OS, but gets <em>cached</em> in the user process's address-space. On fork, the cache gets duplicated, and so more stuff eventually gets flushed out to the OS. You can fix this by doing fflush(stdout) after every printf() (to flush the user-level cache), and you will get the same answer as when using the write() syscall directly.
<hr><p>
  <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
</body>
</html>
